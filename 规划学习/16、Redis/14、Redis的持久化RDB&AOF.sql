Redis的持久化:
	
1、Redis是内存数据库，如果不将内存中的数据库状态保存到磁盘，那么一旦服务器进程出现问题，服务器中的数据库状态
也会消失，所以Redis提供了持久化功能。

2、Redis的持久化有两种方式： RDB(Redis Database) 和 AOF()

3、RDB(Redis Database)
	1、父进程 fork一条 子进程
	2、父进程继续处理客户端的请求， 在内存页面副本进行新的写请求
	3、子进程将内存内容写入临时RDB文件
	4、快照写入完成后，替换原来的快照文件，子进程退出，生成新的正式RDB文件

	在指定的时间间隔内将内存的数据快照写入磁盘，也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到
内存里。
	Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，
再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的。这就确保了极高的性能。
如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那么RDB方式要比AOF方式更加的高效，
RDB的缺点是一次持久后的数据可能丢失。我们默认的就是RDB，一般情况下不需要进行修改这个配置!
	rdb保存的文件是：dump.rdb,都是在我们配置文件中进行配置的。
	
	如何恢复RDB文件？
		1、只需要将rdb文件放在redis启动目录就可以，redis启动的时候会自动检查dump.rdb，恢复其中的数据。
	
	RDB的优缺点：
		优点：
			1、适合大规模的数据恢复！
				因为是主进程fork一个子进程，由子进程进行持久化操作，主进程是不进行任何IO操作的。这就确保了极高的性能。
			2、对数据的完整性要求不高！			
		缺点：
			1、需要一定的时间间隔才会进行持久化操作，如果redis意外宕机了，最后一次修改的数据就没有办法
		持久化了。从未导致缓存数据丢失。
			2、fork子进程的时候，会占用一定的内存空间！！要考虑内存的分布。
			
4、AOF(Append Only File)
	
	1、将我们的所有命令都记录下来，history，恢复的时候就把这个文件全部再执行一遍。
	
	2、以日志的形式来记录每一个写操作，将Redis执行过的所有指令记录下来(读操作不记录)，只许追加文件，但不
可以改写文件，redis启动之初会读取该文件，重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令
从前到后执行一次完成数据的恢复工作。

	3、AOF保存的是appendonly.aof文件
	
	4、AOF的优点和缺点：
		
		1、Redis默认是不开启AOF文件的   
			config配置文件中：appendonly no
			 默认aof文件名称：appendfilename "appendonly.aof"
			 
		2、持久化方式：
			# appendfsync always  --每一次写操作都需要进行追加到aof文件中
			appendfsync everysec  --没一秒进行一次写操作			
			# appendfsync no	  --不进行持久化
			
		优点：
			1、每一次修改都同步，文件的完整性会更好。
			2、每秒同步一次，可能会丢失一秒的数据。
			3、从不同步，效率最高
		
		缺点：
			1、相对于数据文件来说，aof文件远远大于RDB文件，修复的速度也比RDB慢。
			2、AOF运行效率也要比RDB慢，所以Redis的默认配置就是RDB持久化。
			
			
	5、扩展
		1、RDB持久化方式能够在指定的时间间隔内对你的数据进行快照存储。
		
		2、AOF持久化方式记录每次对服务器的写操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据，
	AOF命令以Redis协议追加保存每次的写操作到文件末尾，Redis还能对AOF文件进行后台重写，使得AOF文件不至于过大。
	
		3、只做缓存，如果你只希望你的数据在服务器上运行的时候才存在，你也可以不适用任何持久化。、
		
		4、同时开启两种持久化：
			1、在这种情况下，当redis重启的时候，会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存
		的数据集要比RDB文件保存的数据集要完整。
			2、RDB的数据不实时，同时使用两者时，服务器重启也只会找AOF文件，那要不要只使用AOF呢？
				作者建议不要，因为RDB更适合用于备份数据库（AOF在不断变化不好备份），快速重启，而且也不会有AOF
			可能潜在的Bug，留着作为一个万一的手段。
		
		5、性能建议
			1、因为RDB文件只用作后备用途，建议只在slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留
		save 900 1 这条规则。
			
			2、如果Enable AOF，好处是在罪恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单，只要load自己的
		AOF文件即可。
				带来的代价是：
					1、会带来持续的IO,一直需要将数据追加进aof文件中
					2、AOF rewrite的最后将rewrite过程中产生的新数据写到新文件造成阻塞，几乎是不可避免的。
				只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值是64M太小了，可以将
				其设置到5G以上，默认超过原大小100%大小重写可以改到适当的数值。
					3、如果不Enable AOF， 仅靠Master-slave Repllcation实现高可用性也可以，能省掉一大笔IO,
				也减少了rewrite时带来的系统波动，代价是如果Master/Slave同时倒掉，会丢失十几分钟的数据，
				启动脚本也要比较Master/Slave中的RDB文件，载入较新的那个，微博就是这种架构。
		
		所谓的重写：
			auto-aof-rewrite-percentage 100
			auto-aof-rewrite-min-size 64mb
			
			如果AOF文件大于64M，就会fork一个新的进程来将我们的文件进行重写，这就是rewrite，然后来个
		重命名，保存之前的文件。再重新生成一个新的aof文件，这下就有两个AOF文件了。
				
	
			













	
	
	