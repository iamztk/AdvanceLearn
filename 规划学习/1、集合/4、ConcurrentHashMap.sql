1、hashMap多线程并发访问的情况下，线程不安全的体现：
	a、JDK1.7时：
		hashMap采用的数组 + 链表
		同时在扩容时，链表的扩容采用的是：头插法
		链表的从尾部取值，再进行索引的计算与存值。
		
		正因为：头插法，所以在多线程访问的情况下可能造成死循环。
			例如：链表 A-> B-> C
				线层A： 扩容时 获取锁： 此时拿到B元素，这时 B.next = C
										此时CPU时间耗尽，释放锁
				线程B： 扩容时，获取锁， 并且顺利跑完：则应得到链表： C -> B -> A
										线程结束，释放锁
				线程A 获取锁，继续执行：
							在线程A中，此时B.next = C, 继续往下执行又是  C -> B
							就会陷入死循环。
							
	
	b、JDK1.8中：
		hashMap采用的是：数组+ 链表 + 红黑树
		同时，在扩容的时候，链表的扩容方式是：尾差法
		
		
2、线程安全：
	a、HashTable：
		使用的是:synchronized
		
	b、ConcurrentHashMap:
		1.7以前：
			使用的是分段锁： Segment数组
			
			底层使用的是数组 + 链表
			
			此时的数组，就是Segment数组
			
		1.7以后：
			使用的是： CAS + synchronized
			
			锁由轻转重。
			
			CAS是轻量级锁
			
			synchronized是重量级锁
			
	在JDK1.8以后，对synchronized进行了优化，性能提高了。
				
		