面试官: 那你跟我讲讲HashMap的内部数据结构？
	在jdk1.8之前是 数组 + 链表
	在jdk1.8之后是 数组 + 链表 + 红黑树
	
面试官: 那你清楚HashMap的数据插入原理吗？
	hashmap在put数据的时候：
		1、获取该数据的hash值
		2、判断当前hashmap是否已经初始化了，如果没有，则在插入第一个数据是，进行初始化。
	如果在new HashMap()时，没有指定初始化容量，则默认初始容量为16.
		3、通过hash值 & hashmap.length 获取数据存放的索引值。
		4、获取索引后，判断该索引出是否存在值，如果不存在，则直接插入该位置。
		5、如果该索引处有值，则判断该索引处的值与目前存入的值是否相等，该相等主要是看
			值相等 || equals为true，如果相等则，直接替换掉，即新值替换掉旧值
		6、如果索引处的值不相等，再判断是否为树结构，是，则进行红黑树的模式插入数据。
			否，则是进行链表插入数据。
		7、链表插入数据时，新添加的数会与链表中的每个数逐个比较，如果相同则替换，如果不同
			则比较下一个，如果该链表中没有相同的，则直接插入最后面。
		8、插入完成后，会用当前hashmap中的元素值与该map的临界值比较，如果元素值>临界值
			则需进行扩容。

			
面试官: 刚才你提到HashMap的初始化，那HashMap怎么设定初始容量大小的吗
		没有指定初始容量，则默认初始容量为16
		指定了初始容量也会将指定的容量值转为2^n次幂。

		
面试官: 你提到hash函数，你知道HashMap的哈希函数怎么设计的吗？
		先得到key值的hashcode,然后用该hashcode和 该hashcode右移16位以后进行异或
	得到相应的哈希值。
		(key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16)
		
		
面试官: 那你知道为什么这么设计吗？
		这个设计也叫扰动函数，这样设计有两点原因：
		1、一定要尽可能的降低hash碰撞，越分散越好；
		2、算法一定要高效，因为这是高频操作，所以采用位运算符。



面试官: 为什么采用hashcode的高16位和低16位异或能降低hash碰撞？hash函数能不能直接用key的hashcode？
		因为 key.hashCode() 函数调用的是key键值类型自带的哈希函数，返回int型散列值。int值范围为**-2147483648~2147483647**，
	前后加起来大概40亿的映射空间。只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是一个40亿长度的数组，
	内存是放不下的。你想，如果HashMap数组的初始大小才16，用之前需要对数组的长度取模运算，得到的余数才能用来访问数组下标。
	
		源码中模运算就是把散列值和数组长度-1做一个"与"操作，位运算比%运算要快。

		顺便说一下，这也正好解释了为什么HashMap的数组长度要取2的整数幂。因为这样(数组长度-1)正好相当于一个“低位掩码”。
	“与”操作的结果就是散列值的高位全部归零，只保留低位值，用来做数组下标访问。以初始长度16为例，16-1=15。2进制表示是
	00000000 00000000 00001111。和某散列值做“与”操作如下，结果就是截取了最低的四位值。
	
		但这时候问题就来了，这样就算我的散列值分布再松散，要是只取最后几位的话，碰撞也会很严重。更要命的是如果散列
	本身做得不好，分布上成等差数列的漏洞，如果正好让最后几个低位呈现规律性重复，就无比蛋疼。这时候 hash 函数
	(“扰动函数”)的价值就体现出来了，说到这里大家应该猜出来了。看下面这个图，	
		右位移16位，正好是32bit的一半，自己的高半区和低半区做异或，就是为了混合原始哈希码的高位和低位，以此来加大低
	位的随机性。而且混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留下来。
		最后我们来看一下Peter Lawley的一篇专栏文章《An introduction to optimising a hashing strategy》里的的一个实验：
	他随机选取了352个字符串，在他们散列值完全没有冲突的前提下，对它们做低位掩码，取数组下标。
		结果显示，当HashMap数组长度为512的时候()，也就是用掩码取低9位的时候，在没有扰动函数的情况下，发生了103次碰撞，
	接近30%。而在使用了扰动函数之后只有92次碰撞。碰撞减少了将近10%。看来扰动函数确实还是有功效的。
		另外Java1.8相比1.7做了调整，1.7做了四次移位和四次异或，但明显Java 8觉得扰动做一次就够了，做4次的话，多了可能
	边际效用也不大，所谓为了效率考虑就改成一次了。

	
	
面试官: 看来做过功课，有点料啊！是不是偷偷看了安琪拉的博客公众号, 你刚刚说到1.8对hash函数做了优化，1.8还有别的优化吗？
		1.8还有三点主要的优化：
			1、数组+链表改成了数组+链表或红黑树；
			2、链表的插入方式从头插法改成了尾插法，简单说就是插入时，如果数组位置上已经有元素，1.7将新元素放到数组中，
		原始节点作为新节点的后继节点，1.8遍历链表，将元素放置到链表的最后；
			3、扩容的时候1.7需要对原数组中的元素进行重新hash定位在新数组的位置，1.8采用更简单的判断逻辑，位置不变或
		索引+旧容量大小；
			4、在插入时，1.7先判断是否需要扩容，再插入，1.8先进行插入，插入完成再判断是否需要扩容；



面试官: 你分别跟我讲讲为什么要做这几点优化；					
			1、防止发生hash冲突，链表长度过长，将时间复杂度由O(n)降为O(logn);
			2、因为1.7头插法扩容时，头插法会使链表发生反转，多线程环境下会产生环；
	           A线程在插入节点B，B线程也在插入，遇到容量不够开始扩容，重新hash，放置元素，采用头插法，后遍历到的B节点放入了
			头部，这样形成了环	
	        3、扩容的时候为什么1.8 不用重新hash就可以直接定位原节点在新数据的位置呢?
				这是由于扩容是扩大为原数组大小的2倍，用于计算数组位置的掩码仅仅只是高位多了一个1，举个例子：
					扩容前长度为16，用于计算 (n-1) & hash 的二进制n - 1为0000 1111，
					扩容后为32后的二进制就高位多了1，============>为0001 1111。
					因为是& 运算，1和任何数 & 都是它本身，那就分二种情况，如下图：原数据hashcode高位第4位为0和高位为1的情况；
					第四位高位为0，重新hash数值不变，第四位为1，重新hash数值比原来大16(旧数组的容量)


面试官: 那HashMap是线程安全的吗？
			不是线程安全的。
			JDK1.7之前由于尾插法，在多线程情形下会导致死循环、数据丢失、数据覆盖等问题
			JDK1.8会导致数据覆盖等问题。
		
面试官: 那你平常怎么解决这个线程不安全的问题？
			1、使用hashtable
			2、使用Collections.synchronizedMap(new HashMap());
			3、使用ConcurrentHashMap;		
			
			HashTable是直接在操作方法上加synchronized关键字，锁住整个数组，粒度比较大；
			Collections.synchronizedMap是使用Collections集合工具的内部类，通过传入Map封装出一个SynchronizedMap对象，
		内部定义了一个对象锁，方法内通过对象锁实现；
			ConcurrentHashMap使用分段锁，降低了锁粒度，让并发度大大提高


面试官: 那你知道ConcurrentHashMap的分段锁的实现原理吗？
			1.7之前是 segment分段锁
			1.8之后是 CAS + synchronized
			ConcurrentHashMap成员变量使用volatile 修饰，免除了指令重排序，同时保证内存可见性，另外使用CAS操作和
		synchronized结合实现赋值操作，多线程操作只会锁住当前操作索引的节点。
			如下图，线程A锁住A节点所在链表，线程B锁住B节点所在链表，操作互不干涉

			
面试官: 你前面提到链表转红黑树是链表长度达到阈值，这个阈值是多少？
			阈值是8，红黑树转链表阈值为6
			
			
面试官: 为什么是8，不是16，32甚至是7 ？又为什么红黑树转链表的阈值是6，不是8了呢？
			因为作者就这么设计的，哦，不对，因为经过计算，在hash函数设计合理的情况下，发生hash碰撞8次的几率为百万分之6，
		概率说话。。因为8够用了，至于为什么转回来是6，因为如果hash碰撞次数在8附近徘徊，会一直发生链表和红黑树的转化，
		为了预防这种情况的发生。
			--需要研究

面试官: HashMap内部节点是有序的吗？
			是无序的，根据hash值随机插入
			
			
面试官: 那有没有有序的Map？
			LinkedHashMap 和 TreeMap
			
			
面试官: 跟我讲讲LinkedHashMap怎么实现有序的？
			LinkedHashMap内部维护了一个单链表，有头尾节点，同时LinkedHashMap节点Entry内部除了继承HashMap的Node属性，
		还有before 和 after用于标识前置节点和后置节点。可以实现按插入的顺序或访问顺序排序。

面试官: 跟我讲讲TreeMap怎么实现有序的？
			TreeMap是按照Key的自然顺序或者Comprator的顺序进行排序，内部是通过红黑树来实现。所以要么key所属的类实现
		Comparable接口，或者自定义一个实现了Comparator接口的比较器，传给TreeMap用户key的比较。

面试官: 前面提到通过CAS 和 synchronized结合实现锁粒度的降低，你能给我讲讲CAS 的实现以及synchronized的实现原理吗？
			--需要研究