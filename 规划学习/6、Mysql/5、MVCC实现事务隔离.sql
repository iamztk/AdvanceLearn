1、MVCC：多版本并发控制

2、为什么需要MVCC？
	因为事务是通过锁来实现隔离性的。最原生的锁，在锁住一个资源后，会禁止其他线程访问该资源。
	但是数据大多是读多写少，所以就有了读读不排斥， 读写和写写排斥，极大地提高了系统的并发能力。
	又提出了读写不冲突的想法，以快照的方式将数据保存下来。
	
	MVCC是为了解决数据库访问的并发问题。
	
3、MVCC适用场景：
	只能用在 已提交读： Read Committed
			 不可重复读： Repeatable Read
		另外两个隔离级别与MVCC不兼容。
		
	在Mysql InnoDB中存在多种日志。除了错误日志、查询日志外，还有很多和数据持久性、已执行有关的日志。
		a、redo log: 记录了数据操作在物理层面的修改。
					 当数据库或主机重启时，会根据redo log进行数据恢复。如果redo log里面有事务提交，则进行事务提交修改数据。
		
		b、undo log：除了记录redo log外，当进行数据的修改还会记录undo log， undo log主要用于数据的撤回操作。
					 它记录了修改的反向操作。 可以通过undo log实现事务回滚，并且可以根据undo log回溯到某个特定版本的数据。

		可以理解为：
			redo log：记录的是数据修改后的日志
			undo log：记录的是数据修改前的日志

4、版本链和undo log
			
			innodb中通过B+树作为索引的数据结构，并且主键所在的索引为ClusterIndex(聚簇索引), 
		ClusterIndex中的叶子节点中保存了对应的数据内容。
			一个表只能有一个主键，所以只能有一个聚簇索引，如果表没有定义主键，
		则选择第一个非NULL唯一索引作为聚簇索引，如果还没有则生成一个隐藏id列作为聚簇索引。		
				
		InnoDB行记录中除了刚才提到的rowid外，还有trx_id和db_roll_ptr, 
			trx_id：每次对某条聚簇索引记录进行改动时，都会把对应的事务id赋值给trx_id隐藏列。
			db_roll_pointer：指向undo segment中的undo log,每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到undo日志中，
			然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。 
			
5、ReadView

		ReadView中主要就是有个列表来存储我们系统中当前活跃着的读写事务，
	也就是begin了还未提交的事务。通过这个列表来判断记录的某个版本是否对当前事务可见。其中最主要的与可见性相关的属性如下：

		up_limit_id：当前已经提交的事务号 + 1，事务号 < up_limit_id ，对于当前Read View都是可见的。
	理解起来就是创建Read View视图的时候，之前已经提交的事务对于该事务肯定是可见的。

		low_limit_id：当前最大的事务号 + 1，事务号 >= low_limit_id，对于当前Read View都是不可见的。
	理解起来就是在创建Read View视图之后创建的事务对于该事务肯定是不可见的。

		trx_ids：为活跃事务id列表，即Read View初始化时当前未提交的事务列表。
	所以当进行RR读的时候，trx_ids中的事务对于本事务是不可见的（除了自身事务，自身事务对于表的修改对于自己当然是可见的）。
	理解起来就是创建RV时，将当前活跃事务ID记录下来，后续即使他们提交对于本事务也是不可见的。
	
	
	例：
		当前版本：  事务号： 100
		
		事务A更新：	事务号： 101 （未提交）		
		
		事务B更新：	事务号： 102 （未提交）
		
		事务C查询：	事务号： 103 （未提交）
		
		此时ReadView中存放的活跃事务ID[101,102,103]
		
		此时select时，会顺着版本链往上找，找到第一个不活跃（已提交）的事务，即事务号=100的事务，查找出来
		
		
		这就实现了Read Committed： 事务未提交，是无法查询出来的。
		因为该隔离级别，每一次语句都会生成一个事务号，
		即select时会生成一个新的ReadView, 因为事务号存在于ReadView中，所以自然会有新的事务号：104
		因为如果事务101提交了，此时再去查询，
		此时的ReadView为[102,103]，则会查出事务101提交后的数据，因为此时101已经不活跃了。
		即同一个事务中，两次读取不一致
		
		Repeatable Read： 不可重复读
		由于生成事务号的规则变更了，在事务中，只有第一次会生成一个新的ReadView，后续事务中每次select都是复用该ReadView。
		
		事务B查询时， 此时ReadView是：[101,102,103]  三个活跃事务
		当101提交后，
		B再次查询，此时的ReadView还是[101,102,103],即与第一次读的结果还是一样的，从而实现了不可重复读。
		
6、幻读
	以上Repeatable Read，不可重复读，会产生幻读，是如何产生的？
		如上一致，不可重复读，只会读取第一次select的ReadView的的值，即在该事务内，无论读多少次，都是读的快照数据。
		例如：
			库中数据[a,b],[1,2], [2,3], [3,4],[4,5],[5,5]
			select * from table  a where a.b = 5;  
			第一次查询：返回数据[4,5],[5,5]
			
			此时事务B插入了一条数据：
				insert a (a,b) values(6,5);
				并提交了
			
			第二次查询：返回数据[4,5],[5,5]
			
			然后更新：
				update a set a.b = 6 where a.b=5;
				按照查询出的结果，应该是只更新了两条，即：[4,5],[5,5] -> [4,6],[5,6]
				但是实际结果却是更新了三条：[4,5],[5,5],[6,5] -> [4,6],[5,6],[6,6]
				
			就如同出现了幻觉一样，莫名的更新了3条。称之为幻读。
			
		为什么呢？因为不可重复读的特定，导致只能读取快照数据，而不是实时读取。
		
7、Mysql中是如何解决不可重复读的幻觉问题的？
	通过添加间隙锁。
		Mysql通过间隙锁[Gap Lock]+行锁来解决幻读的问题 
		间隙锁 + 行数 合称为：next-key lock 是前开后闭区间。
		
		间隙锁在不可重复读的隔离级别下才会生效
		间隙锁的原则：（两原则，两优化，一bug）
			1、原则 1：加锁的基本单位是 next-key lock。希望你还记得，next-key lock 是前开后闭区间。

			2、原则 2：查找过程中访问到的对象才会加锁。
			
			3、优化 1：索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁。

			4、优化 2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁。

			5、bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。
			
		
		间隙锁讲解：
			库中数据[a,b],[1,2], [2,3], [3,4],[4,5],[5,5]
			A事务：
			select * from table  a where a.b = 5;  
			第一次查询：返回数据[4,5],[5,5]
				
				在查询的时候会加入间隙锁(4,5],(5,6]这个范围加上间隙锁
			
			此时事务B插入了一条数据：
				insert a (a,b) values(6,5);
				由于加了间隙锁，所以无法进行新增，必须等A事务提交该insert才能执行。
			
			第二次查询：返回数据[4,5],[5,5]
			
			然后更新：
				update a set a.b = 6 where a.b=5;
				就只会更新了两条，即：[4,5],[5,5] -> [4,6],[5,6]
			
			提交以后，事务B才会执行新增语句。此时就能解决幻读。
			
			
总结：
	MVCC实现实现隔离级别：
		Read Committed   已提交读
		Repeatable Read  不可重复读
		
		通过版本链+ReadView: 解决已提交读 问题  和  不可重复读
		
		通过间隙锁（Gap lock ）+行锁 解决幻读问题
	
			
		
		
			
		
		
		
	
		
		
		
		
	
	
	
	
	
	
	
	
	
	
	
	
	