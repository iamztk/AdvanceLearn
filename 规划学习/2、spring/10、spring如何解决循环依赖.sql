1、spring的循环依赖分为：
	1、构造器依赖
	2、属性依赖
	spring能解决的是属性依赖，但是解决不了构造器依赖。
	
--以下的循环依赖，都是基于属性依赖，即通过@AutoWired进行属性注入。
2、Spring的循环依赖是什么？
	类A中：
		@AutoWired
		public B b;
		
	类B中：
		@AutoWired
		public A a;
	即类A中引用类B， 在类B中引用类A。
	

3、如果不解决循环依赖，会有什么结果？
	当实例化A的时候，发现A中有B的引用，则会取实例化B， 在实例化B的时候，又发现有A的引用，则又会去实例化B，此时就会陷入无限循环
导致内存溢出，程序崩溃。
	所以解决该问题，是必要的。
	
4、Spring中是如何解决循环依赖的问题的？
	Spring通过三级缓存，解决了循环依赖的问题。
	解决步骤如下：
		1、在实例化类A的时候，会一次执行doGetBean、查询缓存、createBean创建实例。
		实例化完成后放入三级缓存singletonFactories中，接着执行populateBean方法，装配属性，
		此时发现有一个属性是B的对象。
		
		2、因此需要实例化B，所以在此调用doGetBean方法创建B的实例。依次执行doGetBean、查询
		缓存、createBean创建B的实例，实例化后放入三级缓存中，接着执行populateBean方法，
		装配属性，此时发现有一个属性是A的对象，则又去创建A的实例。
		
		3、创建A的实例，在查询缓存的时候，从三级缓存中查询到了A的实例，就直接返回了A的实例
		不用在执行后续的流程创建A了，自然就不用跑到后续的属性装配环节，从而不会导致所谓的
		循环依赖了。
		
		4、当B能正常装配完成时，A自然也能正常装配完成， 装配完成自然聚能将实例存于一级缓存中。
		
		5、所以Spring用三级缓存完美的解决了循环依赖的问题。
		
		当Bean添加进一级缓存后，则删除掉二三缓存。
		
5、为什么Spring不能解决构造器的循环依赖？
		因为，在Bean调用构造器实例化之前，一二三级缓存并没有Bean的任何相关信息。在实例化
	之后才放入三级缓存中。因此，当getBean的时候缓存并没有命中，这样就跑出了循环依赖的异常了。
	
	
6、为什么多实例Bean不能解决 循环依赖？
		多实例bean是每次创建都会调用doGetBean方法，根本没有使用一二三级缓存，肯定不能解决
	循环依赖。
		多实例bena即原型Bean, Scope = prototype, 在getBean时才创建对象，并且每次都是一个新
	的对象。
		单例Bean， Scope = singleton, 在项目启动时，就创建了bean的对象，存放于单例池中，
	每次使用时，直接从池中获取，每次获取的都是同一个对象。
		